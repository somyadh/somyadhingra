exports.blogPosts = [
    {
        "uid": 1,
        "heading": "Chronicles of a Tech Enthusiast: Prepare to be Amazed (or Mildly Entertained)",
        "summary": "Watch a tech enthusiast bumble through it",
        "fullText": "<html><head><title>Chronicles of a Tech Enthusiast: Prepare to be Amazed (or Mildly Entertained)</title></head><body><p>As an aspiring tech professional, I've always been fascinated by the rapid pace of innovation in the industry.</p><p>From the latest advancements in cloud computing and artificial intelligence to the emergence of cutting-edge web technologies, there's always something new to explore and learn.</p><p>That's why I've decided to start this technical blog - to share my journey of discovery and the insights I gain along the way.</p><h3>My primary goals in writing this blog are:</h3><ol><li><strong>Personal Knowledge Capture</strong>: As I delve into new topics through online courses, industry blogs, and hands-on projects, I want to distill the key learnings into concise, easy-to-reference blog posts. This will help me build a personal knowledge base that I can revisit and build upon over time.</li><li><strong>Building an Online Presence</strong>: By documenting my technical growth and sharing my experiences, I hope to establish an online presence that reflects my skills and expertise. I hope this can be a valuable asset in the tech community, allowing me to connect with like-minded individuals and showcase my passion for the field.</li><li><strong>Fostering Curiosity</strong>: I want to craft blog posts that pique the reader's interest and encourage them to explore the topics further. With our reducing timespan of attention my aim is to provide just enough information to get someone excited about a new technology or concept or even a simple fact.</li></ol><p>Twice a month, you can expect to see blog posts covering a wide range of technical subjects. It can be anything under the sun that picques my intrest, or just something I want to remember and refer back to in future</p><p>Whether you're an experienced engineer, a curious hobbyist, or an aspiring tech professional, I invite you to join me on this journey of exploration and learning.</p><p>I'm excited to connect with like-minded individuals, exchange ideas, and together, push the boundaries of what's possible in the world of technology.</p><p>So, let's get started! I can't wait to share my first technical deep dive with you.</p></body></html>",
        "likes": 0,
        "link": "/1",
        "image": "./techNoobGirl.jpg",
        "imageAltText": "ITech Noob's Adventures",
        "posted_on": '07/04/2024'
    },
    {
        "uid": 2,
        "heading": "AWS CloudFront vs Cloudflare: Traditional CDN vs CDN based on Reverse Proxy",
        "summary": "CDN Titans Comparison",
        "fullText": "<html><head><title>CDN Titans Comparison</title></head><body><h3>Content Delivery Networks (CDNs)</h3><p>CDNs cache and serve content from globally distributed servers, improving load times and availability. Two CDN giants are <strong>AWS CloudFront</strong> and <strong>Cloudflare</strong> - but how do they differ?</p><h3>Operational Models</h3><ul><li><strong>Cloudflare</strong> uses a reverse proxy model, routing traffic through its name servers.</li><li><strong>CloudFront</strong> follows a traditional CDN model, with unique URLs directing traffic to its network.</li></ul><h3>Request Routing</h3><ul><li><strong>Cloudflare</strong> routes requests through its servers, determining optimal paths.</li><li><strong>CloudFront</strong> uses the request's geographic origin to select the closest edge server.</li></ul><h3>Security Features</h3><ul><li><strong>Cloudflare</strong> natively offers DDoS protection, WAF, and SSL/TLS encryption.</li><li><strong>CloudFront</strong> requires integrating AWS Shield and WAF for advanced security.</li></ul><h3>When Cloudflare Shines</h3><ul><li>Cloudflare's reverse proxy model means all traffic goes through Cloudflare's servers before reaching the origin server. This allows Cloudflare to inspect and filter traffic using its built-in security features like DDoS protection and Web Application Firewall (WAF).</li><li>However, since all traffic goes through Cloudflare's servers, there can be some added overhead/latency for non-cacheable or dynamic content that can't be served directly from Cloudflare's edge cache.</li></ul><h3>When CloudFront Shines</h3><ul><li>For AWS-centric architectures, CloudFront seamlessly integrates with other AWS services.</li><li>AWS CloudFront's traditional CDN model is optimized for serving cached static assets from the edge, while dynamic content requests are routed directly to the origin without passing through CloudFront's edge cache. This reduces potential latency for dynamic traffic.</li><li>The trade-off is additional effort to set up security integrations</li></ul><p>While both CDNs boost performance and scale, their architectures and feature sets differ.</p></body></html>",
        "likes": 0,
        "link": "/2",
        "image": "./techNoobGirl.jpg",
        "imageAltText": "ITech Noob's Adventures",
        "posted_on": '20/04/2024'
    },
    {
        "uid": 3,
        "heading": "Node.js, Docker, and Alpine Linux: A Tale of Compatibility Woes",
        "summary": "The Alpine Linux Deception",
        "fullText": "<html><head><title>Node.js, Docker, and Alpine Linux: A Tale of Compatibility Woes</title>\n</head>\n<body> <p>Upgrading Node.js backend from version 10 to 16 and containerizing it with Docker? Easy peasy, right? Well, that's what I thought until I decided to use Alpine Linux for a smaller image size. Little did I know, I was in for a wild ride!</p>\n\n    <p>Issues started popping up left and right, from missing header files to module errors. I felt like I was playing whack-a-mole with error messages. The most memorable ones?</p>\n\n    <pre><code>Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: node-v93-linux-arm64-musl\nFound: [node-v64-darwin-x64-unknown] </code></pre>\n\n    <p>And another one:</p>\n\n    <pre><code>./vendor/abseil-cpp/absl/base/internal/direct_mmap.h:36:10: fatal error: linux/unistd.h: No such file or directory\n308.0 npm ERR! 36 | #include &lt;linux/unistd.h&gt; </code></pre>\n\n    <p>Turns out, the culprit was: Alpine Linux uses musl instead of the more common glibc library. While musl is lightweight and perfect for containers, it can cause compatibility issues. In my case it was <code>node-gyp</code> which required <code>glibc</code></p>\n\n    <p>Alpine has some other issues as well which I didn't encounter but Martin Heinz has written a detailed <a href=\"https://martinheinz.dev/blog/92\">blog</a> around it, including my issue</p>\n\n    <p>In my case I used multi-stage build process to solve this issue. Generally, in the first stage, we use a larger base image (like a full-fledged Debian or Ubuntu) to build and compile app. Then, in the second stage, we copy the compiled artifacts into a Alpine Linux image for production.</p>\n\n    <p>But I wanted even more adventure so I hunted down the required packages in my case it was - <code>libc-dev</code> and <code>linux-headers</code> and used alpine as my base image as well:</p>\n\n    <pre><code># Stage 1: Build the application\nFROM node:16.20.1-alpine as builder\nENV NODE_ENV=production\nWORKDIR /app\nCOPY [\"package.json\", \"./\"]\n\n# Install the necessary build dependencies in the builder image check drive\nRUN apk add --no-cache --virtual .gyp python3 make g++ libc-dev linux-headers \\\n    &amp;&amp; npm install --legacy-peer-deps --production \\\n    &amp;&amp; npm prune --production \\\n    &amp;&amp; apk del .gyp python3 make g++ libc-dev linux-headers\nCOPY . .\n\n# Stage 2: Create a smaller production image\nFROM node:16.20.1-alpine\nENV NODE_ENV=production\nWORKDIR /app\n\n# Copy only the necessary built artifacts and dependencies from the builder stage\nCOPY --from=builder /app .\n\nEXPOSE 9001\nCMD [ \"node\", \"server.js\" ]  </code></pre>\n\n    <p>Ohh by the way this never went to production because of some other unrelated issue. But it taught me a valuable lesson: always be prepared for compatibility adventures when using Alpine Linux!</p>\n</body>\n</html>",
         "likes": 0,
        "link": "/3",
        "image": "./container-issue.jpg",
        "imageAltText": "Girl trying to containerise software",
        "posted_on": '01/05/2024'
    }
    
]